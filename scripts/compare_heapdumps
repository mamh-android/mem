#!/usr/bin/python -E
# This script is to compare two native heap dumps generated by
# "am dumpheap -n <pid> <outfile>"
# Based on script from Freepine <freepine@gmail.com>
# modified by Carton He <carton.he@marvell.com>

import getopt
import sys
import os

class HeapDump:
    'A class to hold info for parsed heapdump file'
    def __init__(self, filename, totalmemory, records, stacks, maps):
        self.filename = filename
        self.totalmemory = totalmemory
        self.records = records
        self.stacks = stacks
        self.maps = maps

class AddressConverter:
    'A class to convert an given address to the corresponding function and file no.'
    maps=[]
    symbols_dir=''
    prebuilt_dir=''
    def __init__(self, maps_lines, symbols_dir):
        self.__readmaps(maps_lines)
        self.symbols_dir = symbols_dir

    def __readmaps(self, maps_lines):
        for line in maps_lines:
            mapitem = self.__parseoneline(line)
            self.maps.append(mapitem)

    def __parseoneline(self, aLine):
        startAddress = int(aLine[0:8], 16)
        if(startAddress <= 0x00010000):
            startAddress = 0
        endAddress = int(aLine[9:17], 16)
        libraryName = (aLine[aLine.find('/'):]).strip()
        return [startAddress, endAddress, libraryName]

    def __findlib(self, address):
        i=0
        while i<len(self.maps) and self.maps[i][0] <= address:
            if self.maps[i][1] >= address:
                return self.maps[i][2], address-self.maps[i][0]
            i = i+1
        return 'Unknown', 0

    def symbolized_address(self, address):
        libname, offset = self.__findlib(address)
        if libname == '/system/vendor/lib/libdvm.so':
            libname = '/system/lib/libdvm.so'

        if libname != 'Unknown':
            cmd = "arm-linux-androideabi-addr2line -f -e " \
                  + self.symbols_dir + libname + " 0x" + `'%x' % offset`
            stream = os.popen(cmd)
            lines = stream.readlines()
            lines = [l.strip() for l in lines]
            stream.close()

            if lines != []:
                cmd = "arm-linux-androideabi-c++filt '" + lines[0] + "'"
                stream = os.popen(cmd)
                lines[0] = stream.readline().strip()
                stream.close()
                return lines[0], lines[1]

        return str(address), libname

    def symbolized_stack(self, stack):
        """stack is a allocation stack trace as a list"""
        return "\n".join(["{0:60} {1}".format(*self.symbolized_address(item)) for item in stack])

def usage():
    print
    print "  usage: " + sys.argv[0] + " [options] <heapdump1> <heapdump2>"
    print
    print "  --symbols-dir=path"
    print "       symbols root dir, default is current dir"
    print
    sys.exit(1)

def parse_heap_dump_file(filename):
    ST_HEADER, ST_STACKS, ST_MAPS = range(0, 3)

    f = file(filename, 'r')
    lines = f.readlines()

    if lines[0].strip() != "Android Native Heap Dump v1.0":
        print "%s is not valid heap dump file" % filename
        usage()

    state = ST_HEADER
    stacks = {}
    maps = []
    for line in lines:
        line = line.strip()
        if state == ST_HEADER:
            if line[:14] == "Total memory: ":
                totalmemory = int(line[14:])
            elif line[:20] == "Allocation records: ":
                records = int(line[20:])
            elif line[:2] == "z ":
                state = ST_STACKS
                # Fall through
        if state == ST_STACKS:
            if line == "MAPS":
                state = ST_MAPS
                continue
            if line[:2] == "z ":  # just to be safe
                words = line.split()
                # Make this dict: (size, stack tuple) => number of allocations
                stack = [int(address, 16) for address in words[7:]]
                stacks[(int(words[3]), tuple(stack))] = int(words[5])
        if state == ST_MAPS:
            if line != "END":
                maps.append(line)

    return HeapDump(filename, totalmemory, records, stacks, maps)

def report_heap_dump_diffs(dump0, dump1, converter):
    print "%s compared with %s:\n" % (dump1.filename, dump0.filename)
    print "total memory increased: %d bytes" % (dump1.totalmemory - dump0.totalmemory)
    print "allocation records increased: %d\n" % (dump1.records - dump0.records)
    print "possibly leaked allocations:"

    i = 0
    for stack, allocations in sorted(dump1.stacks.items(), reverse=True):
        if dump0.stacks.has_key(stack) and dump0.stacks[stack] < allocations:
            print "#%03d: size: %d bytes, allocated %d => %d times:\n%s\n\n" % (i, stack[0],
                    dump0.stacks[stack], allocations, converter.symbolized_stack(stack[1]))
            i += 1

if __name__ == '__main__':
    symbols_dir = '.'

    try:
        options, arguments = getopt.getopt(sys.argv[1:], "", ["symbols-dir=", "help"])
    except getopt.GetoptError, error:
        usage()

    for option, value in options:
        if option == "--help":
            usage()
        if option == "--symbols-dir":
            symbols_dir = value

    if len(arguments) < 2:
        usage()

    dumps = [parse_heap_dump_file(arg) for arg in arguments]
    converter = AddressConverter(dumps[1].maps, symbols_dir)

    report_heap_dump_diffs(dumps[0], dumps[1], converter)
